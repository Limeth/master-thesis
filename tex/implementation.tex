\chapter{Implementation}
The objective of this part of the project was to implement an immersive replication of \acp{ASC} induced by classical psychedelics. In order to achieve a high degree of immersion, our solution was designed to be intended for immersive \ac{VR} systems with \acp{HMD}. Our solution will be referred to with \textit{``the application''} or \textit{``our application''} for the rest of this document.

To represent the \acp{ASC} of classical psychedelics objectively, we had to resort to modelling only the ``perceptual level'' stage of the psychedelic experience (as seen in figure \ref{fig:temporal-dynamics}), as further stages require subjective personalization of content, and aspects less suitable for replication via immersive \ac{VR}, such as cognitive effects and the suppression of the \textit{phenomenological ego}.

\section{Design of the Application}
The application was designed primarily for the evaluation of the implemented replication. The development of the application consisted of 3 distinct parts:

\begin{enumerate}
    \item \textbf{The environment}: A virtual scene that should look as realistic as possible.
    \item \textbf{The replication}: Implementation of the effects themselves.
    \item \textbf{Adaptation for testing}: Getting the application ready for a study, that might measure the impact of the replication on the human mind.
\end{enumerate}

\subsection{Safety}
In order to ensure our application's users safety, we have consulted the \textit{Recommendations for good scientific practice and the consumers of VR-technology} \autocite{madary2016real}. The application was developed according to these recommendations.

Mainly, we don't expect the developed application to have lasting traumatic effects on the users; instead, we believe that this medium may be a suitable way to explore aspects of psychedelic-induced \acp{ASC} while minimizing those risks.

Further, we've taken safety and intuitiveness into account while designing the controls and choosing a suitable testing area for experimentation with \ac{VR} (the ``\ac{VR} play space'').

Finally, the application must be automated, so that the administrator may assist the user and ensure their safety during the usage of the application.

\subsection{Interaction}
Interaction with the scene via hand-held controllers was removed entirely, as we felt that the currently available consumer \ac{VR} technology does not implement a realistic, consistent, universal and intuitive solution for interaction with the virtual scene. For example, in \ac{VR} applications, interactions are usually implemented so that if a user takes a hand-held controller to a dynamic physics-enabled object, they may be able to pick it up by pressing or holding a trigger on the hand-held object, which makes the object stick or snap to the virtual representation of the controller in the scene. While this solution may be suitable for \ac{VR} games, it is still understood as a simplification.

As an alternative, one may consider using force feedback haptic gloves, and given a sufficient physically based simulation, it may be possible to implement realistic interactions with virtual objects. However, even such gloves apply force feedback only to the fingers and not the entire body, making it impossible to, for example, lean against virtual objects.

In any case, no such force feedback haptic gloves were available to us for this project, and so interaction was entirely foregone, in the interest of keeping the simulation focused mainly on the replication, rather than an unrealistic implementation of interactions.

\subsection{Virtual Scene Creation}
Given the goal of creating as realistic of a scene as possible, as well as no financial budget for this project, we ended up choosing \fref{https://web.archive.org/web/20220514231756/https://www.unrealengine.com/en-US}{\acf{UE4}} as the game development engine to develop our \ac{VR} application with. \ac{UE4} is free to use for projects with a lifetime gross revenue below \$1 million USD, and we have no plans to monetize it. Additionally, the choice of \ac{UE4} makes it possible to use the \fref{https://web.archive.org/web/20220514233901/https://quixel.com/megascans}{Quixel Megascans} 3D asset library for free within \ac{UE4}, due to special licensing as a result of the acquisition of Quixel by \fref{https://web.archive.org/web/20220514235540/https://www.epicgames.com/site/en-US/home}{Epic Games}, the developer of \ac{UE4}.

The virtual scene was created with the intended \textit{\ac{VR} play space} in mind, which was measured to be about $3.5\times3.5 \:\si{m^2}$ large. The virtual scene contains visual cues of the \textit{play area} borders in the form of 3D assets; specifically, the \textit{play area} is surrounded by a railing and tall rock, communicating to the user, that these objects should not be passed through.

The choice was made to create an outdoor scene, as the surrounding nature might provide a more pleasant environment than an indoor scene. However, our implementation is in no way limited to outdoor scenes only.

At first, we attempted to create a forest scene, but quickly ran into performance issues while trying to render a densely populated forest on a \ac{HMD}, which requires at least 2 views rendered at typically higher resolutions than a regular desktop screen, ideally with at least 90 \acs{FPS} (the native refresh rate of the \ac{HMD}). Delivering a consistent framerate is a requirement, as low framerates and stuttering may cause motion sickness.

It was then decided to abandon the idea of a forest scene and, instead, use a \ac{HDRI} panoramic photograph as a background (hereinafter ``panoramic background'') for the scene. It is important to note, that a panoramic background has no depth information. This drawback can be mitigated by making only the very distant parts of the panoramic background visible to the user, so that the illusion of the panoramic background being realistic is not broken. The illusion relies on the fact that binocular disparity is low for distant objects.

Close parts of the panoramic background can be hidden with 3D assets suitable for the environment. To minimize the area that needed to be hidden, we have chosen a mountainside panoramic background (see figure \ref{fig:cannon}).

\begin{figure}[H]
    \centering
    \ifgraphics
        \includegraphics[width=0.95\textwidth]{img/cannon.png}
    \fi
    \caption{The chosen panoramic background ``Cannon''\cczerofootnote{Greg Zaal} available on \fref{https://web.archive.org/web/20220515010919/https://polyhaven.com/a/cannon}{Poly Haven}.}\label{fig:cannon}
\end{figure}

The final scene contains a flat patch of grass and other low foliage the size of the \textit{play area}, containing a wooden bench with some gardening tools. The grass patch is surrounded with rock formations and a rocky stairway leading towards it. Beyond the railing, there is a nice view of the sea cove.

\begin{figure}[H]
    \centering
    \ifgraphics
        TODO: image of the scene
        % \includegraphics[width=0.95\textwidth]{img/cannon.png}
    \fi
    \caption{A preview of the resulting scene.}\label{fig:scene-preview}
\end{figure}

\section{Implementation of Replications}

\autocites{preller2016phenomenology}{kometer2016serotonergic}{kleinman1977comparison}

\subsection{Spatial Effects}
\subsubsection{Depth Perception Distortion}

\autocites{fischer1970psilocybin}{dittrich1998standardized}{hill1969effects}{hill1973induction}

\begin{figure}[H]
    \centering
    \ifgraphics
        {
            \def\constepsilon{0.001}
            \def\constymin{-13}
            \def\constymax{7}
            \def\constm{4}
            \def\consta{1.5}
            \def\fnf(#1){(ln(#1) / ln(\consta))}
            \def\fnfinv(#1){((\consta)^(#1))}
            \def\fnoctave(#1){(floor(\fnf(#1)))}
            \def\fnl(#1){(2 * \fnoctave(#1) - \fnf(#1) - \constm + 2)}

            \begin{tikzpicture}
                \begin{axis}[
                    xlabel={Distance from \ac{HMD}},
                    ylabel={Active Octave Indices},
                    samples=1000,
                    grid,
                    thick,
                    domain=0.0000001:10,
                    xmin=0,
                    xmax=10,
                    ymin=\constymin,
                    ymax=\constymax,
                    legend pos=outer north east,
                    no marks,
                    ytick = {-10, -5, 0, 5},
                    minor y tick num=4,
                ]
                    \foreach \y in {\constymin, ..., \constymax}{
                        \def\boundleft{\fpeval{\fnfinv(\y + \constepsilon)}}
                        \def\boundright{\fpeval{\fnfinv(\y + 1 - \constepsilon)}}
                        \edef\temp{
                            \noexpand\fill[black!30!green, fill opacity=0.7] (\boundright, \y) -- plot[domain=\boundleft:\boundright, variable=\noexpand\x] ({\noexpand\x}, {\noexpand\fnf(\noexpand\x)}) -- (\boundright, \y);
                            \noexpand\fill[black!30!green, fill opacity=0.7] (\boundleft, {(\y) - (\constm - 1)}) -- plot[domain=\boundleft:\boundright, variable=\noexpand\x] ({\noexpand\x}, {\noexpand\fnl(\noexpand\x)}) -- (\boundleft, {(\y) - (\constm - 1)});
                        }
                        % \show\temp %-- uncomment this to see what the \temp macro does
                        \temp
                    }

                    \addplot+[draw=none, name path=fnf] {\fnf(x)};
                    \addplot+[draw=none, name path=fnl] {\fnl(x)};

                    \addplot+[draw=black, solid, jump mark mid] {\fnoctave(x) - 0};
                    \addplot+[draw=black, solid, jump mark mid] {\fnoctave(x) - 1};
                    \addplot+[draw=black, solid, jump mark mid] {\fnoctave(x) - 2};
                    \addplot+[draw=black, solid, jump mark mid] {\fnoctave(x) - 3};
                \end{axis}
            \end{tikzpicture}
        }
    \fi
    \caption{Computation of active octaves based on the distance from the \ac{HMD}. Active octaves as solid black lines. Green areas correspond to the weight of the first and last currently active octave.}\label{fig:sharpening}
\end{figure}

\subsubsection{Visual Drifting}

\autocites{diaz2010sacred}{kleinman1977comparison}

\subsection{Non-Spatial Effects}
\subsubsection{Visual Acuity Enhancement}

\autocites{kluver1942mechanisms}{kluver1966mescal}{dittrich1998standardized}{diaz2010sacred}{siegel1975drug}{fischer1969effects}

\begin{figure}[H]
    \centering
    \ifgraphics
        \begin{tikzpicture}[node distance = 2cm, auto]
            \tikzstyle{block} = [rectangle, draw, fill=blue!20, text centered, rounded corners, minimum height=1em]
            \tikzstyle{line} = [draw, -latex']

            \node [block] (verticalblur) {Vertical Gaussian Blur};
            \node [block, below=1.25cm of verticalblur] (horizontalblur) {Horizontal Gaussian Blur};
            \node [block, below=0.5cm of horizontalblur] (unsharpmasking) {Unsharp Masking};

            \node [draw, densely dotted, minimum width=12cm, inner sep=0.5cm, fit=(verticalblur)] (pass1) {};
            \node [draw, densely dotted, minimum width=12cm, inner sep=0.5cm, fit=(horizontalblur)(unsharpmasking)] (pass2) {};

            \node [below right, text width=0.5\textwidth] at (pass1.north west) {{\scriptsize Render Pass A}};
            \node [below right, text width=0.5\textwidth] at (pass2.north west) {{\scriptsize Render Pass B}};

            \path [line] (verticalblur) -> (horizontalblur);
            \path [line] (horizontalblur) -> (unsharpmasking);
        \end{tikzpicture}
    \fi
    \caption{Execution order of distinct components of the sharpening effect.}\label{fig:sharpening}
\end{figure}

\subsubsection{Tracers}

\autocites{hartman1963effect}{diaz2010sacred}{anderson1972trifluoperazine}{kleinman1977comparison}

\begin{figure}[H]
    \centering
    \ifgraphics
        \tikzset{%
          block/.style  = {draw, thick, rectangle, minimum height = 3em, minimum width = 3em},
          op/.style     = {draw, circle, inner sep=-5mm},
          input/.style  = {draw, circle, minimum size=2mm, inner sep=0},
          output/.style = {input},
        }

        \begin{tikzpicture}[auto, thick, >=triangle 45]
            \draw node at (2, 6) [coordinate] (n13) {};
            \draw node at (4, 2) [coordinate] (n21) {};
            \draw node at (0, 6) [input, label={\small Input Frame}] (input) {};
            \draw node at (8, 4) [output, label={\small Modified Frame}] (output) {};
            \draw node at (2, 4) [op, label={left:$1 - \beta^{\Delta t}$}] (n12) {\Large $\times$};
            \draw node at (2, 2) [op] (n11) {\Large $+$};
            \draw node at (2, 0) [op, label={left:$\beta^{\Delta t}$}] (n10) {\Large $\times$};
            \draw node at (6, 6) [op, label={right:$1 - \alpha$}] (n33) {\Large $\times$};
            \draw node at (6, 4) [op] (n32) {\Large $+$};
            \draw node at (6, 2) [op, label={right:$\alpha$}] (n31) {\Large $\times$};
            \draw node at (4, 0) [block, label={right:\small Accumulation Texture}] (accumulator) {\Large $A$};

            \draw[->] (input) -- (n33);
            \draw[->] (n13) -- (n12);
            \draw[->] (n12) -- (n11);
            \draw[->] (n10) -- (n11);
            \draw[->] (accumulator) -- (n10);
            \draw[->] (n33) -- (n32);
            \draw[->] (n31) -- (n32);
            \draw[->] (n11) -- (n31);
            \draw[->] (n21) -- (accumulator);
            \draw[->] (n32) -- (output);
        \end{tikzpicture}
    \fi
    \caption{Execution graph of the tracer effect. The parameter $\alpha \in [0; 1]$ is the total opacity of the effect. The parameter $\beta \in [0; 1]$ is the feedback modifier corresponding to the ``duration'' of the resulting blur. Finally, $\Delta t$ is the time since the previous frame, making the effect less influenced by framerate fluctuations.}\label{fig:tracers-graph}
\end{figure}

\begin{figure}[H]
    \centering
    \ifgraphics
        \begin{tikzpicture}[node distance = 2cm, auto]
            \tikzstyle{block} = [rectangle, draw, fill=blue!20, text centered, rounded corners, minimum height=1em]
            \tikzstyle{line} = [draw, -latex']

            \node [block, dashed, draw=gray, fill=none] (unsharpmasking) {Unsharp Masking};
            \node [block, below=0.5cm of unsharpmasking] (tracers) {Tracers};

            \node [draw, densely dotted, minimum width=12cm, inner sep=0.5cm, fit=(unsharpmasking)(tracers)] (pass2) {};

            \node [below right, text width=0.5\textwidth] at (pass2.north west) {{\scriptsize Render Pass B (Continued)}};

            \path [line] (unsharpmasking) -> (tracers);
        \end{tikzpicture}
    \fi
    \caption{The tracer effect is applied in the second render pass of the sharpening effect.}\label{fig:tracers-order}
\end{figure}

\section{Complex Replication}
\subsection{Execution Order}

\begin{figure}[H]
    \centering
    \ifgraphics
        \begin{tikzpicture}[node distance = 2cm, auto]
            \tikzstyle{block} = [rectangle, draw, fill=blue!20, text centered, rounded corners, minimum height=1em]
            \tikzstyle{line} = [draw, -latex']

            \node [block] (wiggle) {Object Waviness};
            \node [block, below=0.5cm of wiggle] (depthperception) {Depth Perception Distortion};
            \node [block, below=1.25cm of depthperception] (sharpen) {Sharpening};
            \node [block, below=0.5cm of sharpen] (tracers) {Tracers};
            \node [block, below=1.25cm of tracers] (contrast) {Contrast and Saturation};

            \node [draw, densely dotted, minimum width=12cm, inner sep=0.5cm, fit=(wiggle)(depthperception)] (scopematerial) {};
            \node [draw, densely dotted, minimum width=12cm, inner sep=0.5cm, fit=(sharpen)(tracers)] (scopeplugin) {};
            \node [draw, densely dotted, minimum width=12cm, inner sep=0.5cm, fit=(contrast)] (scopeengine) {};

            \node [below right, text width=0.5\textwidth] at (scopematerial.north west) {{\scriptsize Material Graph\\Vertex Shader}};
            \node [below right, text width=0.5\textwidth] at (scopeplugin.north west) {{\scriptsize Engine Plugin Modifying the \acs{RDG}\\Post-Processing}};
            \node [below right, text width=0.5\textwidth] at (scopeengine.north west) {{\scriptsize Engine Built-in\\Post-Processing}};

            \path [line] (wiggle) -> (depthperception);
            \path [line] (depthperception) -> (sharpen);
            \path [line] (sharpen) -> (tracers);
            \path [line] (tracers) -> (contrast);
        \end{tikzpicture}
    \fi
    \caption{The execution order of partial replications, making up the complex replication.}\label{fig:scene-preview}
\end{figure}

\subsection{Experiment Automation}\label{sec:experiment_automation}
